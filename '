use gen_part::*;

use crate::engine::{
    bitboard::Bitboard, color::Color, coordinates::{CompassRose, File, Squares}, masks, r#move::{Move, MoveFlag}, piece::PieceType, position::Position
};
use std::marker::PhantomData;
use crate::engine::coordinates::Square;

pub mod move_type {
    pub struct Legals;
    pub struct PseudoLegals;
    pub struct Attacks;
    pub struct Resolves;
}

pub mod gen_part {
    use std::marker::PhantomData;

    pub struct SingleStep;
    pub struct DoubleStep;
    pub struct PromotionInfo;
    pub struct Promotion<Type>(PhantomData<Type>);
    pub struct PromotionCapture<Direction, Type>(PhantomData<Direction>, PhantomData<Type>);
    pub struct Capture<Direction>(PhantomData<Direction>);
    pub struct EnPassant<Direction>(PhantomData<Direction>);
        
    pub struct West;
    pub struct East;
    pub struct Knight;
    pub struct Bishop;
    pub struct Rook;
    pub struct Queen;
}

pub struct PseudoLegalPawnMovesInfo<'a> {
    pos: &'a Position,
    pawns: Bitboard,
    non_promo_pawns: Bitboard,
    promo_pawns: Bitboard,
    enemies: Bitboard,
    pieces: Bitboard,
}

impl<'a> PseudoLegalPawnMovesInfo<'a> {
    pub fn new(pos: &'a Position, color: Color) -> Self {
        let pawns = pos.get_bitboard(PieceType::Pawn, color);
        let non_promo_pawns = pawns & !masks::RANKS[6];
        let promo_pawns = pawns & masks::RANKS[6];
        let pieces = pos.get_occupancy();
        let enemies = pos.get_color_bb(!color);
        Self {
            pos,
            pawns,
            non_promo_pawns,
            promo_pawns,
            pieces,
            enemies,
        }
    }
}

pub struct PseudoLegalPawnMoves<'a, Part> {
    info: PseudoLegalPawnMovesInfo<'a>,
    blockers: Bitboard,
    from: Bitboard,
    to: Bitboard,
    stage: PhantomData<Part>,
}

impl<'a> PseudoLegalPawnMoves<'a, SingleStep> {
    pub fn new<'b>(info: &'b PseudoLegalPawnMovesInfo<'a>) -> Self {
        let blockers = info.pieces << CompassRose::Sout;
        let to = (info.non_promo_pawns & !blockers) << CompassRose::Nort;
        let from = to << CompassRose::Sout;
        Self {
            info,
            blockers,
            from,
            to,
            stage: PhantomData,
        }
    }
}

impl<'a> PseudoLegalPawnMoves<'a, Capture<West>> {
    pub fn new<'b>(info: &'b PseudoLegalPawnMovesInfo<'a>) -> Self {
        let to = (info.non_promo_pawns & !blockers) << CompassRose::Nort;
        let from = to << CompassRose::Sout;
        Self {
            info,
            blockers,
            from,
            to,
            stage: PhantomData,
        }
    }
}

impl<'a> PseudoLegalPawnMoves<'a, PromotionInfo> {
    pub fn new<'b>(
        prev_part: &'b PseudoLegalPawnMoves<'a, SingleStep>,
        info: &'b PseudoLegalPawnMovesInfo<'a>,
    ) -> Self {
        let blockers = prev_part.blockers;
        let to = (info.promo_pawns & !blockers) << CompassRose::Nort;
        let from = to << CompassRose::Sout;
        Self {
            info,
            blockers,
            from,
            to,
            stage: PhantomData,
        }
    }
}

impl<'a> PseudoLegalPawnMoves<'a, Promotion<Knight>> {
    pub fn new<'b>(
        promo: &'b PseudoLegalPawnMoves<'a, PromotionInfo>,
        info: &'b PseudoLegalPawnMovesInfo<'a>,
    ) -> Self {
        Self {
            info,
            blockers: promo.blockers,
            from: promo.from,
            to: promo.to,
            stage: PhantomData,
        }
    }
}

impl<'a> PseudoLegalPawnMoves<'a, Promotion<Bishop>> {
    pub fn new<'b>(
        promo: &'b PseudoLegalPawnMoves<'a, PromotionInfo>,
        info: &'b PseudoLegalPawnMovesInfo<'a>,
    ) -> Self {
        Self {
            info,
            blockers: promo.blockers,
            from: promo.from,
            to: promo.to,
            stage: PhantomData,
        }
    }
}

impl<'a> PseudoLegalPawnMoves<'a, Promotion<Rook>> {
    pub fn new<'b>(
        promo: &'b PseudoLegalPawnMoves<'a, PromotionInfo>,
        info: &'b PseudoLegalPawnMovesInfo<'a>,
    ) -> Self {
        Self {
            info,
            blockers: promo.blockers,
            from: promo.from,
            to: promo.to,
            stage: PhantomData,
        }
    }
}

impl<'a> PseudoLegalPawnMoves<'a, Promotion<Queen>> {
    pub fn new<'b>(
        prev_part: &'b PseudoLegalPawnMoves<'a, PromotionInfo>,
        info: &'b PseudoLegalPawnMovesInfo<'a>,
    ) -> Self {
        Self {
            info,
            blockers: prev_part.blockers,
            from: prev_part.from,
            to: prev_part.to,
            stage: PhantomData,
        }
    }
}

impl<'a> PseudoLegalPawnMoves<'a, gen_part::DoubleStep> {
    pub fn new<'b>(
        single_step: &'b PseudoLegalPawnMoves<'a, SingleStep>,
        info: &'b PseudoLegalPawnMovesInfo<'a>,
    ) -> Self {
        let blockers = single_step.blockers | info.pieces << (CompassRose::Sout * 2);
        let double_step_pawns = info.pawns & masks::RANKS[1];
        let to = (double_step_pawns & !blockers) << (CompassRose::Nort * 2);
        let from = to << (CompassRose::Sout * 2);
        Self {
            info,
            blockers,
            from,
            to,
            stage: PhantomData,
        }
    }
}

macro_rules! impl_pseudo_legal_pawn_moves {
    ($gen_part:ty, $move_flag:expr) => {
        impl Iterator for PseudoLegalPawnMoves<'_, $gen_part> {
            type Item = Move;

            fn next(&mut self) -> Option<Self::Item> {
                match self.to.pop_lsb() {
                    Square { v: (Squares::None as u8) } => None,
                    sq => Some(Move::new(self.from.pop_lsb(), sq, $move_flag)),
                }
            }
        }
    };
}

impl Iterator for PseudoLegalPawnMoves<'_,SingleStep>{
    type Item = Move;
    fn next(&mut self) -> Option<Self::Item>{
        const none = (Squares::None as u8);
        match self.to.pop_lsb(){
            Square {
                v:
            } => None,
            sq => Some(Move::new(self.from.pop_lsb(),sq,(MoveFlag::Quiet))),
        
            }
    }

    }
impl_pseudo_legal_pawn_moves!(DoubleStep, MoveFlag::DoublePawnPush);
impl_pseudo_legal_pawn_moves!(Promotion<Knight>, MoveFlag::PromotionKnight);
impl_pseudo_legal_pawn_moves!(Promotion<Bishop>, MoveFlag::PromotionBishop);
impl_pseudo_legal_pawn_moves!(Promotion<Rook>, MoveFlag::PromotionRook);
impl_pseudo_legal_pawn_moves!(Promotion<Queen>, MoveFlag::PromotionQueen);

// TODO: test
pub fn white_pawn_attacks(pawn: Bitboard) -> Bitboard {
    let mut result = Bitboard { v: 0 };
    result |= (pawn & !Bitboard::from(File::A)) << CompassRose::West;
    result |= (pawn & !Bitboard::from(File::H)) << CompassRose::East;
    result
}

pub fn generate_moves<'a>(position: &'a Position) -> impl Iterator<Item = Move> + 'a {
    let info = PseudoLegalPawnMovesInfo::new(position, Color::White);
    let single_step = PseudoLegalPawnMoves::<SingleStep>::new(&info);
    let double_step = PseudoLegalPawnMoves::<gen_part::DoubleStep>::new(&single_step, &info);
    let promo = PseudoLegalPawnMoves::<PromotionInfo>::new(&single_step, &info);
    let knight_promo = PseudoLegalPawnMoves::<Promotion<Knight>>::new(&promo, &info);
    let bishop_promo = PseudoLegalPawnMoves::<Promotion<Bishop>>::new(&promo, &info);
    let rook_promo = PseudoLegalPawnMoves::<Promotion<Rook>>::new(&promo, &info);
    let queen_promo = PseudoLegalPawnMoves::<Promotion<Queen>>::new(&promo, &info);
    single_step.into_iter()
        .chain(double_step.into_iter())
        .chain(queen_promo.into_iter())
        .chain(knight_promo.into_iter())
        .chain(bishop_promo.into_iter())
        .chain(rook_promo.into_iter())
}
